import numpy as np
from GraphSigmoidFunction import sigmoid

## 3.4. ~ 3.4.2. 3층 신경망 구현
# 가중치의 방향을 기록할 떄 w^(가중치)_(목적지 뉴런 번호)[(출발지 뉴런 번호)]
# 출발지 뉴런은 편향의 경우 생략할 수 있다.
#
# 한 점으로 들어오는 가중치의 합은 아래 식으로 간소화할 수 있음.
# A = WX + B
#
# 본 코드에서는 활성화 함수 대신 np.dot 만을 이용함.
# 프로세스 요약:
# - X1, X2 두 입력을 받음
# - 1층) W1[0](X1의 가중치), W1[1](X2의 가중치)를  가짐
# - 1층) W2[0](X1의 가중치), W2[1](X2의 가중치)를  가짐
# ---------------------------------------------------
# 학습노트
# (2023-12-05) 아직 편향 값을 설정하는 기준에 대해 이해가 안됨
#
# =========================== 1층 ===========================
X = np.array([1.0, 0.5])
W1 = np.array([[0.1, 0.3, 0.5], [0.2, 0.4, 0.6]])
B1 = np.array([0.1, 0.2, 0.3])

print(W1.shape)
print(X.shape)
print(B1.shape)

A1 = np.dot(X, W1) + B1
print(A1)

# 시그모이드 함수 적용
Z1 = sigmoid(A1)
print(Z1)

# =========================== 2층 ===========================
W2 = np.array([[0.1, 0.4], [0.2, 0.5], [0.3, 0.6]])
B2 = np.array([0.1, 0.2])

# 1층에서의 출력을 2층의 입력으로 사용
A2 = np.dot(Z1, W2) + B2
Z2 = sigmoid(A2)
print(Z2)


# =========================== 3층(출력층) ===========================
# ps) 항등 함수. 생략 가능, 그동안의 실행 로직과 비슷하게 작성하고자 해당 구현 추가.
def identity_function(x):
    return x

W3 = np.array([[0.1, 0.3], [0.2, 0.4]])
B3 = np.array([0.1, 0.2])

A3 = np.dot(Z2, W3) + B3
Y = identity_function(A3) # identity_function 생략 가능 -> Y = A3
print(Y)